{"info":{"type":"runner","start":"2022-07-03T04:46:50.707Z","_duration":20241,"cid":"0-0","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"103.0.5060.66","chrome":{"chromedriverVersion":"102.0.5005.61 (0e59bcc00cc4985ce39ad31c150065f159d95ad3-refs/branch-heads/5005@{#819})","userDataDir":"C:\\Users\\daspa\\AppData\\Local\\Temp\\scoped_dir29164_182290375"},"goog:chromeOptions":{"debuggerAddress":"localhost:63803"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c"},"sanitizedCapabilities":"chrome.103_0_5060_66.windows","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"info","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"enableDirectConnect":true,"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./features/**/*.feature"],"exclude":[],"suites":{},"baseUrl":"http://localhost:8081","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"cucumber","reporters":["spec",["html-nice",{"outputDir":"./reports/html-reports/","filename":"report.html","reportTitle":"Test Report Title","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":5,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"onWorkerEnd":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["C:\\Users\\daspa\\OneDrive\\Desktop\\TS automation\\features\\cart.feature"],"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","isMultiremote":false,"instanceOptions":{"e5e016ec99e0db26c7609c84e00dbd7c":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"info","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"enableDirectConnect":true,"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./features/**/*.feature"],"exclude":[],"suites":{},"baseUrl":"http://localhost:8081","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"cucumber","reporters":["spec",["html-nice",{"outputDir":"./reports/html-reports/","filename":"report.html","reportTitle":"Test Report Title","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":5,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"onWorkerEnd":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":0,"retries":0,"end":"2022-07-03T04:47:10.948Z"},"metrics":{"passed":9,"skipped":0,"failed":0,"duration":20241,"start":"2022-07-03T04:46:50.708Z","end":"2022-07-03T04:47:10Z"},"title":"Test Report Title","suites":[{"type":"feature","start":"2022-07-03T04:46:50.973Z","_duration":19912,"tests":[],"hooks":[],"suites":[{"type":"scenario","start":"2022-07-03T04:46:50.989Z","_duration":14069,"tests":[{"type":"test","start":"2022-07-03T04:46:50.991Z","_duration":17,"uid":"9","cid":"0-0","title":"Given I am on the home page","fullTitle":"0: Given I am on the home page","output":[{"method":"POST","endpoint":"/session/:sessionId/window/maximize","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"http://localhost:8081/"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:46:51.008Z"},{"type":"test","start":"2022-07-03T04:46:51.008Z","_duration":14018,"uid":"10","cid":"0-0","title":"When I click on the add to cart button of 1","fullTitle":"0: When I click on the add to cart button of 1","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_1']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/window/maximize","body":{},"result":{"value":{"height":832,"width":1552,"x":-8,"y":-8}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"http://localhost:8081/"},"result":{"value":null},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_1']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"11f4c148-bbdf-44e7-84d1-49776c545b86"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"11f4c148-bbdf-44e7-84d1-49776c545b86","ELEMENT":"11f4c148-bbdf-44e7-84d1-49776c545b86"}]},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"11f4c148-bbdf-44e7-84d1-49776c545b86","ELEMENT":"11f4c148-bbdf-44e7-84d1-49776c545b86"}]},"result":{"value":true},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/11f4c148-bbdf-44e7-84d1-49776c545b86/click","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/11f4c148-bbdf-44e7-84d1-49776c545b86/click","body":{},"result":{"value":null},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:05.026Z"},{"type":"test","start":"2022-07-03T04:47:05.027Z","_duration":30,"uid":"11","cid":"0-0","title":"Then I can see 1 no of product added to cart","fullTitle":"0: Then I can see 1 no of product added to cart","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[contains(@class,'MuiBadge-anchorOriginTopRightRectangular')]"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[contains(@class,'MuiBadge-anchorOriginTopRightRectangular')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8ca7dcbf-7514-485f-8eda-56c0d5268961"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8ca7dcbf-7514-485f-8eda-56c0d5268961/text","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8ca7dcbf-7514-485f-8eda-56c0d5268961/text","body":{},"result":{"value":"1"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:05.057Z"}],"hooks":[{"type":"hook","start":"2022-07-03T04:46:50.990Z","_duration":0,"uid":"33","cid":"0-0","title":"","parent":"0","errors":[],"end":"2022-07-03T04:46:50.990Z"},{"type":"hook","start":"2022-07-03T04:47:05.057Z","_duration":1,"uid":"37","cid":"0-0","title":"","parent":"0","errors":[],"end":"2022-07-03T04:47:05.058Z"}],"suites":[],"hooksAndTests":[{"type":"hook","start":"2022-07-03T04:46:50.990Z","_duration":0,"uid":"33","cid":"0-0","title":"","parent":"0","errors":[],"end":"2022-07-03T04:46:50.990Z"},{"type":"test","start":"2022-07-03T04:46:50.991Z","_duration":17,"uid":"9","cid":"0-0","title":"Given I am on the home page","fullTitle":"0: Given I am on the home page","output":[{"method":"POST","endpoint":"/session/:sessionId/window/maximize","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"http://localhost:8081/"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:46:51.008Z"},{"type":"test","start":"2022-07-03T04:46:51.008Z","_duration":14018,"uid":"10","cid":"0-0","title":"When I click on the add to cart button of 1","fullTitle":"0: When I click on the add to cart button of 1","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_1']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/window/maximize","body":{},"result":{"value":{"height":832,"width":1552,"x":-8,"y":-8}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"http://localhost:8081/"},"result":{"value":null},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_1']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"11f4c148-bbdf-44e7-84d1-49776c545b86"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"11f4c148-bbdf-44e7-84d1-49776c545b86","ELEMENT":"11f4c148-bbdf-44e7-84d1-49776c545b86"}]},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"11f4c148-bbdf-44e7-84d1-49776c545b86","ELEMENT":"11f4c148-bbdf-44e7-84d1-49776c545b86"}]},"result":{"value":true},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/11f4c148-bbdf-44e7-84d1-49776c545b86/click","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/11f4c148-bbdf-44e7-84d1-49776c545b86/click","body":{},"result":{"value":null},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:05.026Z"},{"type":"test","start":"2022-07-03T04:47:05.027Z","_duration":30,"uid":"11","cid":"0-0","title":"Then I can see 1 no of product added to cart","fullTitle":"0: Then I can see 1 no of product added to cart","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[contains(@class,'MuiBadge-anchorOriginTopRightRectangular')]"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[contains(@class,'MuiBadge-anchorOriginTopRightRectangular')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8ca7dcbf-7514-485f-8eda-56c0d5268961"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8ca7dcbf-7514-485f-8eda-56c0d5268961/text","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8ca7dcbf-7514-485f-8eda-56c0d5268961/text","body":{},"result":{"value":"1"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:05.057Z"},{"type":"hook","start":"2022-07-03T04:47:05.057Z","_duration":1,"uid":"37","cid":"0-0","title":"","parent":"0","errors":[],"end":"2022-07-03T04:47:05.058Z"}],"uid":"0","cid":"0-0","file":"C:\\Users\\daspa\\OneDrive\\Desktop\\TS automation\\features\\cart.feature","title":"Test add to cart","fullTitle":"cart.feature:1:1: Test add to cart","tags":[],"parent":"cart.feature:1:1","end":"2022-07-03T04:47:05.059Z"},{"type":"scenario","start":"2022-07-03T04:47:05.059Z","_duration":3674,"tests":[{"type":"test","start":"2022-07-03T04:47:05.060Z","_duration":4,"uid":"13","cid":"0-0","title":"Given I am on the home page","fullTitle":"1: Given I am on the home page","output":[{"method":"POST","endpoint":"/session/:sessionId/window/maximize","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"http://localhost:8081/"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:05.064Z"},{"type":"test","start":"2022-07-03T04:47:05.064Z","_duration":3594,"uid":"14","cid":"0-0","title":"When I click on the add to cart button of 2","fullTitle":"1: When I click on the add to cart button of 2","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/window/maximize","body":{},"result":{"value":{"height":832,"width":1552,"x":-8,"y":-8}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"http://localhost:8081/"},"result":{"value":null},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//button[@id='cart_2']\"}\n  (Session info: chrome=103.0.5060.66)","stacktrace":"Backtrace:\n\tOrdinal0 [0x0062D953+2414931]\n\tOrdinal0 [0x005BF5E1+1963489]\n\tOrdinal0 [0x004AC6B8+837304]\n\tOrdinal0 [0x004D9500+1021184]\n\tOrdinal0 [0x004D979B+1021851]\n\tOrdinal0 [0x00506502+1205506]\n\tOrdinal0 [0x004F44E4+1131748]\n\tOrdinal0 [0x00504812+1198098]\n\tOrdinal0 [0x004F42B6+1131190]\n\tOrdinal0 [0x004CE860+976992]\n\tOrdinal0 [0x004CF756+980822]\n\tGetHandleVerifier [0x0089CC62+2510274]\n\tGetHandleVerifier [0x0088F760+2455744]\n\tGetHandleVerifier [0x006BEABA+551962]\n\tGetHandleVerifier [0x006BD916+547446]\n\tOrdinal0 [0x005C5F3B+1990459]\n\tOrdinal0 [0x005CA898+2009240]\n\tOrdinal0 [0x005CA985+2009477]\n\tOrdinal0 [0x005D3AD1+2046673]\n\tBaseThreadInitThunk [0x75586739+25]\n\tRtlGetFullPathName_UEx [0x776E8FEF+1215]\n\tRtlGetFullPathName_UEx [0x776E8FBD+1165]\n"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//button[@id='cart_2']\"}\n  (Session info: chrome=103.0.5060.66)","stacktrace":"Backtrace:\n\tOrdinal0 [0x0062D953+2414931]\n\tOrdinal0 [0x005BF5E1+1963489]\n\tOrdinal0 [0x004AC6B8+837304]\n\tOrdinal0 [0x004D9500+1021184]\n\tOrdinal0 [0x004D979B+1021851]\n\tOrdinal0 [0x00506502+1205506]\n\tOrdinal0 [0x004F44E4+1131748]\n\tOrdinal0 [0x00504812+1198098]\n\tOrdinal0 [0x004F42B6+1131190]\n\tOrdinal0 [0x004CE860+976992]\n\tOrdinal0 [0x004CF756+980822]\n\tGetHandleVerifier [0x0089CC62+2510274]\n\tGetHandleVerifier [0x0088F760+2455744]\n\tGetHandleVerifier [0x006BEABA+551962]\n\tGetHandleVerifier [0x006BD916+547446]\n\tOrdinal0 [0x005C5F3B+1990459]\n\tOrdinal0 [0x005CA898+2009240]\n\tOrdinal0 [0x005CA985+2009477]\n\tOrdinal0 [0x005D3AD1+2046673]\n\tBaseThreadInitThunk [0x75586739+25]\n\tRtlGetFullPathName_UEx [0x776E8FEF+1215]\n\tRtlGetFullPathName_UEx [0x776E8FBD+1165]\n"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//button[@id='cart_2']\"}\n  (Session info: chrome=103.0.5060.66)","stacktrace":"Backtrace:\n\tOrdinal0 [0x0062D953+2414931]\n\tOrdinal0 [0x005BF5E1+1963489]\n\tOrdinal0 [0x004AC6B8+837304]\n\tOrdinal0 [0x004D9500+1021184]\n\tOrdinal0 [0x004D979B+1021851]\n\tOrdinal0 [0x00506502+1205506]\n\tOrdinal0 [0x004F44E4+1131748]\n\tOrdinal0 [0x00504812+1198098]\n\tOrdinal0 [0x004F42B6+1131190]\n\tOrdinal0 [0x004CE860+976992]\n\tOrdinal0 [0x004CF756+980822]\n\tGetHandleVerifier [0x0089CC62+2510274]\n\tGetHandleVerifier [0x0088F760+2455744]\n\tGetHandleVerifier [0x006BEABA+551962]\n\tGetHandleVerifier [0x006BD916+547446]\n\tOrdinal0 [0x005C5F3B+1990459]\n\tOrdinal0 [0x005CA898+2009240]\n\tOrdinal0 [0x005CA985+2009477]\n\tOrdinal0 [0x005D3AD1+2046673]\n\tBaseThreadInitThunk [0x75586739+25]\n\tRtlGetFullPathName_UEx [0x776E8FEF+1215]\n\tRtlGetFullPathName_UEx [0x776E8FBD+1165]\n"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//button[@id='cart_2']\"}\n  (Session info: chrome=103.0.5060.66)","stacktrace":"Backtrace:\n\tOrdinal0 [0x0062D953+2414931]\n\tOrdinal0 [0x005BF5E1+1963489]\n\tOrdinal0 [0x004AC6B8+837304]\n\tOrdinal0 [0x004D9500+1021184]\n\tOrdinal0 [0x004D979B+1021851]\n\tOrdinal0 [0x00506502+1205506]\n\tOrdinal0 [0x004F44E4+1131748]\n\tOrdinal0 [0x00504812+1198098]\n\tOrdinal0 [0x004F42B6+1131190]\n\tOrdinal0 [0x004CE860+976992]\n\tOrdinal0 [0x004CF756+980822]\n\tGetHandleVerifier [0x0089CC62+2510274]\n\tGetHandleVerifier [0x0088F760+2455744]\n\tGetHandleVerifier [0x006BEABA+551962]\n\tGetHandleVerifier [0x006BD916+547446]\n\tOrdinal0 [0x005C5F3B+1990459]\n\tOrdinal0 [0x005CA898+2009240]\n\tOrdinal0 [0x005CA985+2009477]\n\tOrdinal0 [0x005D3AD1+2046673]\n\tBaseThreadInitThunk [0x75586739+25]\n\tRtlGetFullPathName_UEx [0x776E8FEF+1215]\n\tRtlGetFullPathName_UEx [0x776E8FBD+1165]\n"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"04db1327-c280-4b48-aae6-52d91d66c1ae"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"04db1327-c280-4b48-aae6-52d91d66c1ae","ELEMENT":"04db1327-c280-4b48-aae6-52d91d66c1ae"}]},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"04db1327-c280-4b48-aae6-52d91d66c1ae","ELEMENT":"04db1327-c280-4b48-aae6-52d91d66c1ae"}]},"result":{"value":true},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/04db1327-c280-4b48-aae6-52d91d66c1ae/click","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/04db1327-c280-4b48-aae6-52d91d66c1ae/click","body":{},"result":{"value":null},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:08.658Z"},{"type":"test","start":"2022-07-03T04:47:08.658Z","_duration":74,"uid":"15","cid":"0-0","title":"Then I can see 2 no of product added to cart","fullTitle":"1: Then I can see 2 no of product added to cart","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[contains(@class,'MuiBadge-anchorOriginTopRightRectangular')]"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[contains(@class,'MuiBadge-anchorOriginTopRightRectangular')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f3009c63-4fc1-48c3-a1d5-2ac9c2c83d35"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f3009c63-4fc1-48c3-a1d5-2ac9c2c83d35/text","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f3009c63-4fc1-48c3-a1d5-2ac9c2c83d35/text","body":{},"result":{"value":"2"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:08.732Z"}],"hooks":[{"type":"hook","start":"2022-07-03T04:47:05.059Z","_duration":1,"uid":"39","cid":"0-0","title":"","parent":"1","errors":[],"end":"2022-07-03T04:47:05.060Z"},{"type":"hook","start":"2022-07-03T04:47:08.732Z","_duration":0,"uid":"43","cid":"0-0","title":"","parent":"1","errors":[],"end":"2022-07-03T04:47:08.732Z"}],"suites":[],"hooksAndTests":[{"type":"hook","start":"2022-07-03T04:47:05.059Z","_duration":1,"uid":"39","cid":"0-0","title":"","parent":"1","errors":[],"end":"2022-07-03T04:47:05.060Z"},{"type":"test","start":"2022-07-03T04:47:05.060Z","_duration":4,"uid":"13","cid":"0-0","title":"Given I am on the home page","fullTitle":"1: Given I am on the home page","output":[{"method":"POST","endpoint":"/session/:sessionId/window/maximize","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"http://localhost:8081/"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:05.064Z"},{"type":"test","start":"2022-07-03T04:47:05.064Z","_duration":3594,"uid":"14","cid":"0-0","title":"When I click on the add to cart button of 2","fullTitle":"1: When I click on the add to cart button of 2","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/window/maximize","body":{},"result":{"value":{"height":832,"width":1552,"x":-8,"y":-8}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"http://localhost:8081/"},"result":{"value":null},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//button[@id='cart_2']\"}\n  (Session info: chrome=103.0.5060.66)","stacktrace":"Backtrace:\n\tOrdinal0 [0x0062D953+2414931]\n\tOrdinal0 [0x005BF5E1+1963489]\n\tOrdinal0 [0x004AC6B8+837304]\n\tOrdinal0 [0x004D9500+1021184]\n\tOrdinal0 [0x004D979B+1021851]\n\tOrdinal0 [0x00506502+1205506]\n\tOrdinal0 [0x004F44E4+1131748]\n\tOrdinal0 [0x00504812+1198098]\n\tOrdinal0 [0x004F42B6+1131190]\n\tOrdinal0 [0x004CE860+976992]\n\tOrdinal0 [0x004CF756+980822]\n\tGetHandleVerifier [0x0089CC62+2510274]\n\tGetHandleVerifier [0x0088F760+2455744]\n\tGetHandleVerifier [0x006BEABA+551962]\n\tGetHandleVerifier [0x006BD916+547446]\n\tOrdinal0 [0x005C5F3B+1990459]\n\tOrdinal0 [0x005CA898+2009240]\n\tOrdinal0 [0x005CA985+2009477]\n\tOrdinal0 [0x005D3AD1+2046673]\n\tBaseThreadInitThunk [0x75586739+25]\n\tRtlGetFullPathName_UEx [0x776E8FEF+1215]\n\tRtlGetFullPathName_UEx [0x776E8FBD+1165]\n"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//button[@id='cart_2']\"}\n  (Session info: chrome=103.0.5060.66)","stacktrace":"Backtrace:\n\tOrdinal0 [0x0062D953+2414931]\n\tOrdinal0 [0x005BF5E1+1963489]\n\tOrdinal0 [0x004AC6B8+837304]\n\tOrdinal0 [0x004D9500+1021184]\n\tOrdinal0 [0x004D979B+1021851]\n\tOrdinal0 [0x00506502+1205506]\n\tOrdinal0 [0x004F44E4+1131748]\n\tOrdinal0 [0x00504812+1198098]\n\tOrdinal0 [0x004F42B6+1131190]\n\tOrdinal0 [0x004CE860+976992]\n\tOrdinal0 [0x004CF756+980822]\n\tGetHandleVerifier [0x0089CC62+2510274]\n\tGetHandleVerifier [0x0088F760+2455744]\n\tGetHandleVerifier [0x006BEABA+551962]\n\tGetHandleVerifier [0x006BD916+547446]\n\tOrdinal0 [0x005C5F3B+1990459]\n\tOrdinal0 [0x005CA898+2009240]\n\tOrdinal0 [0x005CA985+2009477]\n\tOrdinal0 [0x005D3AD1+2046673]\n\tBaseThreadInitThunk [0x75586739+25]\n\tRtlGetFullPathName_UEx [0x776E8FEF+1215]\n\tRtlGetFullPathName_UEx [0x776E8FBD+1165]\n"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//button[@id='cart_2']\"}\n  (Session info: chrome=103.0.5060.66)","stacktrace":"Backtrace:\n\tOrdinal0 [0x0062D953+2414931]\n\tOrdinal0 [0x005BF5E1+1963489]\n\tOrdinal0 [0x004AC6B8+837304]\n\tOrdinal0 [0x004D9500+1021184]\n\tOrdinal0 [0x004D979B+1021851]\n\tOrdinal0 [0x00506502+1205506]\n\tOrdinal0 [0x004F44E4+1131748]\n\tOrdinal0 [0x00504812+1198098]\n\tOrdinal0 [0x004F42B6+1131190]\n\tOrdinal0 [0x004CE860+976992]\n\tOrdinal0 [0x004CF756+980822]\n\tGetHandleVerifier [0x0089CC62+2510274]\n\tGetHandleVerifier [0x0088F760+2455744]\n\tGetHandleVerifier [0x006BEABA+551962]\n\tGetHandleVerifier [0x006BD916+547446]\n\tOrdinal0 [0x005C5F3B+1990459]\n\tOrdinal0 [0x005CA898+2009240]\n\tOrdinal0 [0x005CA985+2009477]\n\tOrdinal0 [0x005D3AD1+2046673]\n\tBaseThreadInitThunk [0x75586739+25]\n\tRtlGetFullPathName_UEx [0x776E8FEF+1215]\n\tRtlGetFullPathName_UEx [0x776E8FBD+1165]\n"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//button[@id='cart_2']\"}\n  (Session info: chrome=103.0.5060.66)","stacktrace":"Backtrace:\n\tOrdinal0 [0x0062D953+2414931]\n\tOrdinal0 [0x005BF5E1+1963489]\n\tOrdinal0 [0x004AC6B8+837304]\n\tOrdinal0 [0x004D9500+1021184]\n\tOrdinal0 [0x004D979B+1021851]\n\tOrdinal0 [0x00506502+1205506]\n\tOrdinal0 [0x004F44E4+1131748]\n\tOrdinal0 [0x00504812+1198098]\n\tOrdinal0 [0x004F42B6+1131190]\n\tOrdinal0 [0x004CE860+976992]\n\tOrdinal0 [0x004CF756+980822]\n\tGetHandleVerifier [0x0089CC62+2510274]\n\tGetHandleVerifier [0x0088F760+2455744]\n\tGetHandleVerifier [0x006BEABA+551962]\n\tGetHandleVerifier [0x006BD916+547446]\n\tOrdinal0 [0x005C5F3B+1990459]\n\tOrdinal0 [0x005CA898+2009240]\n\tOrdinal0 [0x005CA985+2009477]\n\tOrdinal0 [0x005D3AD1+2046673]\n\tBaseThreadInitThunk [0x75586739+25]\n\tRtlGetFullPathName_UEx [0x776E8FEF+1215]\n\tRtlGetFullPathName_UEx [0x776E8FBD+1165]\n"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_2']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"04db1327-c280-4b48-aae6-52d91d66c1ae"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"04db1327-c280-4b48-aae6-52d91d66c1ae","ELEMENT":"04db1327-c280-4b48-aae6-52d91d66c1ae"}]},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"04db1327-c280-4b48-aae6-52d91d66c1ae","ELEMENT":"04db1327-c280-4b48-aae6-52d91d66c1ae"}]},"result":{"value":true},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/04db1327-c280-4b48-aae6-52d91d66c1ae/click","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/04db1327-c280-4b48-aae6-52d91d66c1ae/click","body":{},"result":{"value":null},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:08.658Z"},{"type":"test","start":"2022-07-03T04:47:08.658Z","_duration":74,"uid":"15","cid":"0-0","title":"Then I can see 2 no of product added to cart","fullTitle":"1: Then I can see 2 no of product added to cart","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[contains(@class,'MuiBadge-anchorOriginTopRightRectangular')]"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[contains(@class,'MuiBadge-anchorOriginTopRightRectangular')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f3009c63-4fc1-48c3-a1d5-2ac9c2c83d35"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f3009c63-4fc1-48c3-a1d5-2ac9c2c83d35/text","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f3009c63-4fc1-48c3-a1d5-2ac9c2c83d35/text","body":{},"result":{"value":"2"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:08.732Z"},{"type":"hook","start":"2022-07-03T04:47:08.732Z","_duration":0,"uid":"43","cid":"0-0","title":"","parent":"1","errors":[],"end":"2022-07-03T04:47:08.732Z"}],"uid":"1","cid":"0-0","file":"C:\\Users\\daspa\\OneDrive\\Desktop\\TS automation\\features\\cart.feature","title":"Test add to cart","fullTitle":"cart.feature:1:1: Test add to cart","tags":[],"parent":"cart.feature:1:1","end":"2022-07-03T04:47:08.733Z"},{"type":"scenario","start":"2022-07-03T04:47:08.733Z","_duration":2150,"tests":[{"type":"test","start":"2022-07-03T04:47:08.734Z","_duration":3,"uid":"17","cid":"0-0","title":"Given I am on the home page","fullTitle":"2: Given I am on the home page","output":[{"method":"POST","endpoint":"/session/:sessionId/window/maximize","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"http://localhost:8081/"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:08.737Z"},{"type":"test","start":"2022-07-03T04:47:08.737Z","_duration":2116,"uid":"18","cid":"0-0","title":"When I click on the add to cart button of 4","fullTitle":"2: When I click on the add to cart button of 4","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_4']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/window/maximize","body":{},"result":{"value":{"height":832,"width":1552,"x":-8,"y":-8}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"http://localhost:8081/"},"result":{"value":null},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_4']"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//button[@id='cart_4']\"}\n  (Session info: chrome=103.0.5060.66)","stacktrace":"Backtrace:\n\tOrdinal0 [0x0062D953+2414931]\n\tOrdinal0 [0x005BF5E1+1963489]\n\tOrdinal0 [0x004AC6B8+837304]\n\tOrdinal0 [0x004D9500+1021184]\n\tOrdinal0 [0x004D979B+1021851]\n\tOrdinal0 [0x00506502+1205506]\n\tOrdinal0 [0x004F44E4+1131748]\n\tOrdinal0 [0x00504812+1198098]\n\tOrdinal0 [0x004F42B6+1131190]\n\tOrdinal0 [0x004CE860+976992]\n\tOrdinal0 [0x004CF756+980822]\n\tGetHandleVerifier [0x0089CC62+2510274]\n\tGetHandleVerifier [0x0088F760+2455744]\n\tGetHandleVerifier [0x006BEABA+551962]\n\tGetHandleVerifier [0x006BD916+547446]\n\tOrdinal0 [0x005C5F3B+1990459]\n\tOrdinal0 [0x005CA898+2009240]\n\tOrdinal0 [0x005CA985+2009477]\n\tOrdinal0 [0x005D3AD1+2046673]\n\tBaseThreadInitThunk [0x75586739+25]\n\tRtlGetFullPathName_UEx [0x776E8FEF+1215]\n\tRtlGetFullPathName_UEx [0x776E8FBD+1165]\n"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_4']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_4']"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//button[@id='cart_4']\"}\n  (Session info: chrome=103.0.5060.66)","stacktrace":"Backtrace:\n\tOrdinal0 [0x0062D953+2414931]\n\tOrdinal0 [0x005BF5E1+1963489]\n\tOrdinal0 [0x004AC6B8+837304]\n\tOrdinal0 [0x004D9500+1021184]\n\tOrdinal0 [0x004D979B+1021851]\n\tOrdinal0 [0x00506502+1205506]\n\tOrdinal0 [0x004F44E4+1131748]\n\tOrdinal0 [0x00504812+1198098]\n\tOrdinal0 [0x004F42B6+1131190]\n\tOrdinal0 [0x004CE860+976992]\n\tOrdinal0 [0x004CF756+980822]\n\tGetHandleVerifier [0x0089CC62+2510274]\n\tGetHandleVerifier [0x0088F760+2455744]\n\tGetHandleVerifier [0x006BEABA+551962]\n\tGetHandleVerifier [0x006BD916+547446]\n\tOrdinal0 [0x005C5F3B+1990459]\n\tOrdinal0 [0x005CA898+2009240]\n\tOrdinal0 [0x005CA985+2009477]\n\tOrdinal0 [0x005D3AD1+2046673]\n\tBaseThreadInitThunk [0x75586739+25]\n\tRtlGetFullPathName_UEx [0x776E8FEF+1215]\n\tRtlGetFullPathName_UEx [0x776E8FBD+1165]\n"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_4']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_4']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"136c6394-555f-44c0-9d20-0f10a0810c27"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"136c6394-555f-44c0-9d20-0f10a0810c27","ELEMENT":"136c6394-555f-44c0-9d20-0f10a0810c27"}]},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"136c6394-555f-44c0-9d20-0f10a0810c27","ELEMENT":"136c6394-555f-44c0-9d20-0f10a0810c27"}]},"result":{"value":true},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/136c6394-555f-44c0-9d20-0f10a0810c27/click","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/136c6394-555f-44c0-9d20-0f10a0810c27/click","body":{},"result":{"value":null},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:10.853Z"},{"type":"test","start":"2022-07-03T04:47:10.853Z","_duration":30,"uid":"19","cid":"0-0","title":"Then I can see 3 no of product added to cart","fullTitle":"2: Then I can see 3 no of product added to cart","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[contains(@class,'MuiBadge-anchorOriginTopRightRectangular')]"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[contains(@class,'MuiBadge-anchorOriginTopRightRectangular')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"626c463d-fe9e-4aff-b69d-8df70219a7c6"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/626c463d-fe9e-4aff-b69d-8df70219a7c6/text","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/626c463d-fe9e-4aff-b69d-8df70219a7c6/text","body":{},"result":{"value":"3"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:10.883Z"}],"hooks":[{"type":"hook","start":"2022-07-03T04:47:08.734Z","_duration":0,"uid":"45","cid":"0-0","title":"","parent":"2","errors":[],"end":"2022-07-03T04:47:08.734Z"},{"type":"hook","start":"2022-07-03T04:47:10.883Z","_duration":0,"uid":"49","cid":"0-0","title":"","parent":"2","errors":[],"end":"2022-07-03T04:47:10.883Z"}],"suites":[],"hooksAndTests":[{"type":"hook","start":"2022-07-03T04:47:08.734Z","_duration":0,"uid":"45","cid":"0-0","title":"","parent":"2","errors":[],"end":"2022-07-03T04:47:08.734Z"},{"type":"test","start":"2022-07-03T04:47:08.734Z","_duration":3,"uid":"17","cid":"0-0","title":"Given I am on the home page","fullTitle":"2: Given I am on the home page","output":[{"method":"POST","endpoint":"/session/:sessionId/window/maximize","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"http://localhost:8081/"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:08.737Z"},{"type":"test","start":"2022-07-03T04:47:08.737Z","_duration":2116,"uid":"18","cid":"0-0","title":"When I click on the add to cart button of 4","fullTitle":"2: When I click on the add to cart button of 4","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_4']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/window/maximize","body":{},"result":{"value":{"height":832,"width":1552,"x":-8,"y":-8}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"http://localhost:8081/"},"result":{"value":null},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_4']"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//button[@id='cart_4']\"}\n  (Session info: chrome=103.0.5060.66)","stacktrace":"Backtrace:\n\tOrdinal0 [0x0062D953+2414931]\n\tOrdinal0 [0x005BF5E1+1963489]\n\tOrdinal0 [0x004AC6B8+837304]\n\tOrdinal0 [0x004D9500+1021184]\n\tOrdinal0 [0x004D979B+1021851]\n\tOrdinal0 [0x00506502+1205506]\n\tOrdinal0 [0x004F44E4+1131748]\n\tOrdinal0 [0x00504812+1198098]\n\tOrdinal0 [0x004F42B6+1131190]\n\tOrdinal0 [0x004CE860+976992]\n\tOrdinal0 [0x004CF756+980822]\n\tGetHandleVerifier [0x0089CC62+2510274]\n\tGetHandleVerifier [0x0088F760+2455744]\n\tGetHandleVerifier [0x006BEABA+551962]\n\tGetHandleVerifier [0x006BD916+547446]\n\tOrdinal0 [0x005C5F3B+1990459]\n\tOrdinal0 [0x005CA898+2009240]\n\tOrdinal0 [0x005CA985+2009477]\n\tOrdinal0 [0x005D3AD1+2046673]\n\tBaseThreadInitThunk [0x75586739+25]\n\tRtlGetFullPathName_UEx [0x776E8FEF+1215]\n\tRtlGetFullPathName_UEx [0x776E8FBD+1165]\n"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_4']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_4']"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//button[@id='cart_4']\"}\n  (Session info: chrome=103.0.5060.66)","stacktrace":"Backtrace:\n\tOrdinal0 [0x0062D953+2414931]\n\tOrdinal0 [0x005BF5E1+1963489]\n\tOrdinal0 [0x004AC6B8+837304]\n\tOrdinal0 [0x004D9500+1021184]\n\tOrdinal0 [0x004D979B+1021851]\n\tOrdinal0 [0x00506502+1205506]\n\tOrdinal0 [0x004F44E4+1131748]\n\tOrdinal0 [0x00504812+1198098]\n\tOrdinal0 [0x004F42B6+1131190]\n\tOrdinal0 [0x004CE860+976992]\n\tOrdinal0 [0x004CF756+980822]\n\tGetHandleVerifier [0x0089CC62+2510274]\n\tGetHandleVerifier [0x0088F760+2455744]\n\tGetHandleVerifier [0x006BEABA+551962]\n\tGetHandleVerifier [0x006BD916+547446]\n\tOrdinal0 [0x005C5F3B+1990459]\n\tOrdinal0 [0x005CA898+2009240]\n\tOrdinal0 [0x005CA985+2009477]\n\tOrdinal0 [0x005D3AD1+2046673]\n\tBaseThreadInitThunk [0x75586739+25]\n\tRtlGetFullPathName_UEx [0x776E8FEF+1215]\n\tRtlGetFullPathName_UEx [0x776E8FBD+1165]\n"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_4']"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@id='cart_4']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"136c6394-555f-44c0-9d20-0f10a0810c27"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"136c6394-555f-44c0-9d20-0f10a0810c27","ELEMENT":"136c6394-555f-44c0-9d20-0f10a0810c27"}]},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"136c6394-555f-44c0-9d20-0f10a0810c27","ELEMENT":"136c6394-555f-44c0-9d20-0f10a0810c27"}]},"result":{"value":true},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/136c6394-555f-44c0-9d20-0f10a0810c27/click","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/136c6394-555f-44c0-9d20-0f10a0810c27/click","body":{},"result":{"value":null},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:10.853Z"},{"type":"test","start":"2022-07-03T04:47:10.853Z","_duration":30,"uid":"19","cid":"0-0","title":"Then I can see 3 no of product added to cart","fullTitle":"2: Then I can see 3 no of product added to cart","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[contains(@class,'MuiBadge-anchorOriginTopRightRectangular')]"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[contains(@class,'MuiBadge-anchorOriginTopRightRectangular')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"626c463d-fe9e-4aff-b69d-8df70219a7c6"}},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/626c463d-fe9e-4aff-b69d-8df70219a7c6/text","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/626c463d-fe9e-4aff-b69d-8df70219a7c6/text","body":{},"result":{"value":"3"},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"e5e016ec99e0db26c7609c84e00dbd7c","cid":"0-0","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0,"end":"2022-07-03T04:47:10.883Z"},{"type":"hook","start":"2022-07-03T04:47:10.883Z","_duration":0,"uid":"49","cid":"0-0","title":"","parent":"2","errors":[],"end":"2022-07-03T04:47:10.883Z"}],"uid":"2","cid":"0-0","file":"C:\\Users\\daspa\\OneDrive\\Desktop\\TS automation\\features\\cart.feature","title":"Test add to cart","fullTitle":"cart.feature:1:1: Test add to cart","tags":[],"parent":"cart.feature:1:1","end":"2022-07-03T04:47:10.884Z"}],"hooksAndTests":[],"uid":"cart.feature:1:1","cid":"0-0","file":"C:\\Users\\daspa\\OneDrive\\Desktop\\TS automation\\features\\cart.feature","title":"Test cart page","tags":[],"description":"","end":"2022-07-03T04:47:10.887Z"}],"reportFile":"C:\\Users\\daspa\\OneDrive\\Desktop\\TS automation\\reports\\html-reports\\2\\0-0\\report.html"}